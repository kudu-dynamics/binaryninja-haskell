stages:
  - deps:build
  - deps:push
  - build
  - test

# FIXME it would be _nice_ if we could run branch pipelines _until_ branches become MRs, in which
# case we run MR pipelines. Cf. https://gitlab.com/gitlab-org/gitlab/-/issues/34756#note_282820625
# This may be possible starting with gitlab 13.7: https://gitlab.com/gitlab-org/gitlab/-/merge_requests/38673
workflow:
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_MERGE_REQUEST_ID == null
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

variables:
  REPO_DOCKER_REGISTRY: ${CI_REGISTRY_IMAGE}
  BLAZE_BINARYNINJA_HASKELL_BASE_IMAGE:
    ${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}/devops/binaryninja-haskell-base:latest
  DOCKER_BUILDKIT: "1"

.job:
  timeout: 1h
  before_script:
    - echo -e "section_start:`date +%s`:bootstrap[collapsed=true]\r\e[0KBootstrap build dependencies"
    - |
      if [ -f /etc/alpine-release ]; then
        apk add git coreutils
        apk add -X http://dl-cdn.alpinelinux.org/alpine/edge/testing time
      fi
    - echo -e "section_end:`date +%s`:bootstrap\r\e[0K"

    - echo -e "section_start:`date +%s`:pre-env[collapsed=true]\r\e[0KEnvironment info (before_script)"
    - uname -a
    - env
    - ls -al
    - find . -maxdepth 1 \( ! -name . \) -print0 | sort -z | xargs -0 -x du -bhsc
    - echo -e "section_end:`date +%s`:pre-env\r\e[0K"

    - echo -e "section_start:`date +%s`:setup[collapsed=true]\r\e[0KProject Setup"
    - echo -e "machine ${CI_SERVER_HOST}\nlogin gitlab-ci-token\npassword ${CI_JOB_TOKEN}" > ~/.netrc
    - |
      cat <<EOF >../.dockerignore
      *

      !binaryninja-haskell
      !binary-analysis

      **/.git
      **/.gitlab-ci.yml

      **/.stack
      **/.stack-work*

      **/*.cabal

      **/dist-newstyle
      **/dist

      **/Dockerfile*
      **/.dockerignore
      EOF
    - |
      for project in binary-analysis; do
        rm -rf "../${project}"
        git clone --depth=1 "${CI_REPOSITORY_URL%/*}/${project}.git" "../${project}"
      done
    - echo -e "section_end:`date +%s`:setup\r\e[0K"
  after_script:
    - echo -e "section_start:`date +%s`:post-env[collapsed=true]\r\e[0KEnvironment info (after_script)"
    - ls -al
    - find . -maxdepth 1 \( ! -name . \) -print0 | sort -z | xargs -0 -x du -bhsc
    - echo -e "section_end:`date +%s`:post-env\r\e[0K"

.haskell-job:
  extends: .job
  image: ${REPO_DOCKER_REGISTRY}/binaryninja-haskell-deps:commit-${CI_COMMIT_SHA}
  tags:
    - dind

deps:build:branch:
  stage: deps:build
  extends: .job
  image: docker:dind
  tags:
    - dind
  # rules:
  #   - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
  #     changes:
  #       - "**/Dockerfile*"
  #       - "**/.gitlab-ci.yml"
  #       - "**/stack.yaml"
  #       - "**/stack.yaml.lock"
  #       - "**/package.yaml"
  #       - "**/*.cabal"
  script:
    - docker login -u "${CI_REGISTRY_USER}" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
    - \time -v docker build --pull .. -f Dockerfile.base
      --build-arg BLAZE_BINARYNINJA_HASKELL_BASE_IMAGE="${BLAZE_BINARYNINJA_HASKELL_BASE_IMAGE}"
      -t "${REPO_DOCKER_REGISTRY}/binaryninja-haskell-deps:commit-${CI_COMMIT_SHA}"
      -t "${REPO_DOCKER_REGISTRY}/binaryninja-haskell-deps:branch-${CI_COMMIT_REF_SLUG}"
    - docker push "${REPO_DOCKER_REGISTRY}/binaryninja-haskell-deps:commit-${CI_COMMIT_SHA}"
    - docker push "${REPO_DOCKER_REGISTRY}/binaryninja-haskell-deps:branch-${CI_COMMIT_REF_SLUG}"

deps:push:latest:
  stage: deps:push
  extends: .job
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  needs:
    - deps:build:branch
  variables:
    GIT_STRATEGY: none
  script:
    - docker pull "${REPO_DOCKER_REGISTRY}/binaryninja-haskell-deps:commit-${CI_COMMIT_SHA}"
    - docker tag "${REPO_DOCKER_REGISTRY}/binaryninja-haskell-deps:commit-${CI_COMMIT_SHA}" "${REPO_DOCKER_REGISTRY}/binaryninja-haskell-deps:latest"
    - docker push "${REPO_DOCKER_REGISTRY}/binaryninja-haskell-deps:latest"

build:
  extends: .haskell-job
  stage: build
  script:
    - "( cd ../haskell-binja && make header && git diff --stat && git checkout . ; )"
    - stack build

test:
  extends: .haskell-job
  stage: test
  script:
    - stack test
  allow_failure: true
