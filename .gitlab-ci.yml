stages:
  - lint
  - build
  - test
  - push
  - docs

# FIXME it would be _nice_ if we could run branch pipelines _until_ branches become MRs, in which
# case we run MR pipelines. Cf. https://gitlab.com/gitlab-org/gitlab/-/issues/34756#note_282820625
# This may be possible starting with gitlab 13.7: https://gitlab.com/gitlab-org/gitlab/-/merge_requests/38673
workflow:
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_MERGE_REQUEST_ID == null
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

variables:
  # The base of this repo's docker registry
  REPO_DOCKER_REGISTRY: ${CI_REGISTRY_IMAGE}
  # The image name of binaryninja-haskell-base
  BLAZE_BINARYNINJA_HASKELL_BASE_IMAGE:
    ${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}/devops/binaryninja-haskell-base
  # Enable buildkit for more efficient layer caching
  DOCKER_BUILDKIT: "1"

.dind:
  image: docker:dind
  tags:
    - dind
  timeout: 1h
  before_script:
    # TODO gitlab 13.5 pre-collapse debug/environment info sections to reduce log noise
    # Potential build dependencies for the dind host
    - echo -e "section_start:`date +%s`:bootstrap\r\e[0KBootstrap build dependencies"
    - |
      if [ -f /etc/alpine-release ]; then
        apk add git coreutils python3
        apk add -X http://dl-cdn.alpinelinux.org/alpine/edge/testing time
      fi
    - echo -e "section_end:`date +%s`:bootstrap\r\e[0K"

    # Print runner environment info for debugging
    - echo -e "section_start:`date +%s`:pre-env\r\e[0KEnvironment info (before_script)"
    - uname -a
    - env
    - ls -al
    - find . -maxdepth 1 \( ! -name . \) -print0 | sort -z | xargs -0 -x du -bhsc
    - echo -e "section_end:`date +%s`:pre-env\r\e[0K"

    # Setup source dependencies
    - echo -e "section_start:`date +%s`:setup\r\e[0KProject Setup"
    # Login to gitlab so we can clone
    - echo -e "machine ${CI_SERVER_HOST}\nlogin gitlab-ci-token\npassword ${CI_JOB_TOKEN}" > ~/.netrc
    # Write a .dockerignore to the build context (../). This ignores everything there except for
    # our source dependencies, since gitlab runner will have cloned our other repos to ../
    - |
      cat <<EOF >../.dockerignore
      *

      !binaryninja-haskell
      !binary-analysis

      **/.git
      **/.gitlab-ci.yml

      **/.stack
      **/.stack-work*

      **/*.cabal

      **/dist-newstyle
      **/dist

      **/Dockerfile*
      **/.dockerignore
      EOF
    # Clone each source dependency
    - |
      for project in binary-analysis; do
        rm -rf "../${project}"
        git clone --depth=1 "${CI_REPOSITORY_URL%/*}/${project}.git" "../${project}"
      done
    - echo -e "section_end:`date +%s`:setup\r\e[0K"

.haskell-job:
  extends: .dind
  image: ${REPO_DOCKER_REGISTRY}/binaryninja-haskell:commit-${CI_COMMIT_SHA}
  # Skip .dind before_script, especially the environment info, since we don't
  # care about most of it after the build stage
  before_script: []

lint:
  stage: lint
  extends: .dind
  image: ${BLAZE_BINARYNINJA_HASKELL_BASE_IMAGE}
  needs: []
  script:
    - hlint --color=always src test demo
  allow_failure: true

# We need 2 build jobs: one for branch pipelines and one for MR pipelines
# - build:branch pushes to
#   - ${image}:commit-${CI_COMMIT_SHA}
#   - ${image}:branch-${CI_COMMIT_REF_SLUG}
#   For instance, binaryninja-haskell:branch-feature-foo and binaryninja-haskell:commit-1a2b3c4...
# - build:detached pushes to
#   - ${image}:merge-${CI_MERGE_REQUEST_IID}
#   For instance, binaryninja-haskell:merge-71
# In either case, we should first try pulling the latest image for this branch or MR,
# and if that fails, pull :latest. This ensures we have cached layers downloaded

build:branch:
  stage: build
  extends: .dind
  rules:
    - if: $CI_MERGE_REQUEST_IID == null
  needs: []
  script:
    - image=${REPO_DOCKER_REGISTRY}/binaryninja-haskell
    - docker login -u "${CI_REGISTRY_USER}" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
    - docker pull "${image}:branch-${CI_COMMIT_REF_SLUG}" ||
      docker pull "${image}:latest" ||
      true
    - \time -v docker build --pull .. -f Dockerfile
      -t "${image}:commit-${CI_COMMIT_SHA}"
      -t "${image}:branch-${CI_COMMIT_REF_SLUG}"
    - docker push "${image}:commit-${CI_COMMIT_SHA}"
    - docker push "${image}:branch-${CI_COMMIT_REF_SLUG}"

build:detached:
  stage: build
  extends: .dind
  rules:
    - if: $CI_MERGE_REQUEST_IID
  needs: []
  script:
    - image=${REPO_DOCKER_REGISTRY}/binaryninja-haskell
    - docker login -u "${CI_REGISTRY_USER}" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
    - docker pull "${image}:merge-${CI_MERGE_REQUEST_IID}" ||
      docker pull "${image}:latest" ||
      true
    - \time -v docker build --pull .. -f Dockerfile
      -t "${image}:merge-${CI_MERGE_REQUEST_IID}"
    - docker push "${image}:merge-${CI_MERGE_REQUEST_IID}"

# Likewise, we need 2 test jobs. The test:branch job uses the ${image}:commit-... image,
# and the test:detached uses the ${image}:merge-... image

test:branch:
  stage: test
  extends: .haskell-job
  rules:
    - if: $CI_MERGE_REQUEST_IID == null
  needs:
    - build:branch
  variables:
    GIT_STRATEGY: none
    GIT_CLEAN_FLAGS: none
  script:
    - cd /blaze/binaryninja-haskell
    - STACK_TEST_TIMEOUT=1800 .ci/scripts/run_stack_test.py

test:detached:
  stage: test
  extends: .haskell-job
  image: ${REPO_DOCKER_REGISTRY}/binaryninja-haskell:merge-${CI_MERGE_REQUEST_IID}
  rules:
    - if: $CI_MERGE_REQUEST_IID
  needs:
    - build:detached
  variables:
    GIT_STRATEGY: none
    GIT_CLEAN_FLAGS: none
  script:
    - cd /blaze/binaryninja-haskell
    - STACK_TEST_TIMEOUT=1800 .ci/scripts/run_stack_test.py

# If we just pushed to the default branch, tag the image as :latest and push

push:latest:
  stage: push
  extends: .dind
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  needs:
    - test:branch
  variables:
    GIT_STRATEGY: none
    GIT_CLEAN_FLAGS: none
  script:
    - image=${REPO_DOCKER_REGISTRY}/binaryninja-haskell
    - docker login -u "${CI_REGISTRY_USER}" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
    - docker pull "${image}:commit-${CI_COMMIT_SHA}"
    - docker tag "${image}:commit-${CI_COMMIT_SHA}" "${image}:latest"
    - docker push "${image}:latest"

pages:
  extends: .haskell-job
  stage: docs
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_MERGE_REQUEST_ID == null
      when: on_success
    - if: $CI_MERGE_REQUEST_ID == null
      when: manual
  needs:
    - test:branch
  variables:
    GIT_STRATEGY: none
    GIT_CLEAN_FLAGS: none
  script:
    - pushd /blaze/blaze-ui/server
    - stack haddock --no-haddock-deps
    - docs_dir=$(stack path --snapshot-doc-root)
    - popd
    - cp -arT "$docs_dir" public
  allow_failure: true
  artifacts:
    paths:
      - public
    expire_in: 12 hours
